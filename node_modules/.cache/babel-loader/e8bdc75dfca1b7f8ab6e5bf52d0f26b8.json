{"ast":null,"code":"/// <reference types=\"cypress\" />\n// @ts-check\nvar _require = require('./support-utils'),\n    filterSpecsFromCoverage = _require.filterSpecsFromCoverage;\n/**\n * Sends collected code coverage object to the backend code\n * via \"cy.task\".\n */\n\n\nvar sendCoverage = function sendCoverage(coverage) {\n  var pathname = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '/';\n  logMessage(\"Saving code coverage for **\".concat(pathname, \"**\"));\n  var withoutSpecs = filterSpecsFromCoverage(coverage);\n  var appCoverageOnly = filterSupportFilesFromCoverage(withoutSpecs); // stringify coverage object for speed\n\n  cy.task('combineCoverage', JSON.stringify(appCoverageOnly), {\n    log: false\n  });\n};\n/**\n * Consistently logs the given string to the Command Log\n * so the user knows the log message is coming from this plugin.\n * @param {string} s Message to log.\n */\n\n\nvar logMessage = function logMessage(s) {\n  cy.log(\"\".concat(s, \" `[@cypress/code-coverage]`\"));\n};\n/**\n * Removes support file from the coverage object.\n * If there are more files loaded from support folder, also removes them\n */\n\n\nvar filterSupportFilesFromCoverage = function filterSupportFilesFromCoverage(totalCoverage) {\n  var integrationFolder = Cypress.config('integrationFolder');\n  var supportFile = Cypress.config('supportFile'); // @ts-ignore\n\n  var supportFolder = Cypress.config('supportFolder');\n\n  var isSupportFile = function isSupportFile(filename) {\n    return filename === supportFile;\n  };\n\n  var coverage = Cypress._.omitBy(totalCoverage, function (fileCoverage, filename) {\n    return isSupportFile(filename);\n  }); // check the edge case\n  //   if we have files from support folder AND the support folder is not same\n  //   as the integration, or its prefix (this might remove all app source files)\n  //   then remove all files from the support folder\n\n\n  if (!integrationFolder.startsWith(supportFolder)) {\n    // remove all covered files from support folder\n    coverage = Cypress._.omitBy(totalCoverage, function (fileCoverage, filename) {\n      return filename.startsWith(supportFolder);\n    });\n  }\n\n  return coverage;\n};\n\nvar registerHooks = function registerHooks() {\n  var windowCoverageObjects;\n\n  var hasE2ECoverage = function hasE2ECoverage() {\n    return Boolean(windowCoverageObjects.length);\n  }; // @ts-ignore\n\n\n  var hasUnitTestCoverage = function hasUnitTestCoverage() {\n    return Boolean(window.__coverage__);\n  };\n\n  before(function () {\n    // we need to reset the coverage when running\n    // in the interactive mode, otherwise the counters will\n    // keep increasing every time we rerun the tests\n    var logInstance = Cypress.log({\n      name: 'Coverage',\n      message: ['Reset [@cypress/code-coverage]']\n    });\n    cy.task('resetCoverage', {\n      // @ts-ignore\n      isInteractive: Cypress.config('isInteractive')\n    }, {\n      log: false\n    }).then(function () {\n      logInstance.end();\n    });\n  });\n  beforeEach(function () {\n    // each object will have the coverage and url pathname\n    // to let the user know the coverage has been collected\n    windowCoverageObjects = [];\n\n    var saveCoverageObject = function saveCoverageObject(win) {\n      // if application code has been instrumented, the app iframe \"window\" has an object\n      var applicationSourceCoverage = win.__coverage__;\n\n      if (!applicationSourceCoverage) {\n        return;\n      }\n\n      if (Cypress._.find(windowCoverageObjects, {\n        coverage: applicationSourceCoverage\n      })) {\n        // this application code coverage object is already known\n        // which can happen when combining `window:load` and `before` callbacks\n        return;\n      }\n\n      windowCoverageObjects.push({\n        coverage: applicationSourceCoverage,\n        pathname: win.location.pathname\n      });\n    }; // save reference to coverage for each app window loaded in the test\n\n\n    cy.on('window:load', saveCoverageObject); // save reference if visiting a page inside a before() hook\n\n    cy.window({\n      log: false\n    }).then(saveCoverageObject);\n  });\n  afterEach(function () {\n    // save coverage after the test\n    // because now the window coverage objects have been updated\n    windowCoverageObjects.forEach(function (cover) {\n      sendCoverage(cover.coverage, cover.pathname);\n    });\n\n    if (!hasE2ECoverage()) {\n      if (hasUnitTestCoverage()) {\n        logMessage(\"\\uD83D\\uDC49 Only found unit test code coverage.\");\n      } else {\n        logMessage(\"\\n          \\u26A0\\uFE0F Could not find any coverage information in your application\\n          by looking at the window coverage object.\\n          Did you forget to instrument your application?\\n          See [code-coverage#instrument-your-application](https://github.com/cypress-io/code-coverage#instrument-your-application)\\n        \");\n      }\n    }\n  });\n  after(function collectBackendCoverage() {\n    // I wish I could fail the tests if there is no code coverage information\n    // but throwing an error here does not fail the test run due to\n    // https://github.com/cypress-io/cypress/issues/2296\n    // there might be server-side code coverage information\n    // we should grab it once after all tests finish\n    // @ts-ignore\n    var baseUrl = Cypress.config('baseUrl') || cy.state('window').origin; // @ts-ignore\n\n    var runningEndToEndTests = baseUrl !== Cypress.config('proxyUrl');\n\n    var specType = Cypress._.get(Cypress.spec, 'specType', 'integration');\n\n    var isIntegrationSpec = specType === 'integration';\n\n    if (runningEndToEndTests && isIntegrationSpec) {\n      // we can only request server-side code coverage\n      // if we are running end-to-end tests,\n      // otherwise where do we send the request?\n      var url = Cypress._.get(Cypress.env('codeCoverage'), 'url', '/__coverage__');\n\n      cy.request({\n        url: url,\n        log: false,\n        failOnStatusCode: false\n      }).then(function (r) {\n        return Cypress._.get(r, 'body.coverage', null);\n      }).then(function (coverage) {\n        if (!coverage) {\n          // we did not get code coverage - this is the\n          // original failed request\n          return;\n        }\n\n        sendCoverage(coverage, 'backend');\n      });\n    }\n  });\n  after(function mergeUnitTestCoverage() {\n    // collect and merge frontend coverage\n    // if spec bundle has been instrumented (using Cypress preprocessor)\n    // then we will have unit test coverage\n    // NOTE: spec iframe is NOT reset between the tests, so we can grab\n    // the coverage information only once after all tests have finished\n    // @ts-ignore\n    var unitTestCoverage = window.__coverage__;\n\n    if (unitTestCoverage) {\n      sendCoverage(unitTestCoverage, 'unit');\n    }\n  });\n  after(function generateReport() {\n    // when all tests finish, lets generate the coverage report\n    var logInstance = Cypress.log({\n      name: 'Coverage',\n      message: ['Generating report [@cypress/code-coverage]']\n    });\n    cy.task('coverageReport', null, {\n      timeout: Cypress.moment.duration(3, 'minutes').asMilliseconds(),\n      log: false\n    }).then(function (coverageReportFolder) {\n      logInstance.set('consoleProps', function () {\n        return {\n          'coverage report folder': coverageReportFolder\n        };\n      });\n      logInstance.end();\n      return coverageReportFolder;\n    });\n  });\n}; // to disable code coverage commands and save time\n// pass environment variable coverage=false\n//  cypress run --env coverage=false\n// or\n//  CYPRESS_coverage=false cypress run\n// see https://on.cypress.io/environment-variables\n// to avoid \"coverage\" env variable being case-sensitive, convert to lowercase\n\n\nvar cyEnvs = Cypress._.mapKeys(Cypress.env(), function (value, key) {\n  return key.toLowerCase();\n});\n\nif (cyEnvs.coverage === false) {\n  console.log('Skipping code coverage hooks');\n} else if (Cypress.env('codeCoverageTasksRegistered') !== true) {\n  // register a hook just to log a message\n  before(function () {\n    logMessage(\"\\n      \\u26A0\\uFE0F Code coverage tasks were not registered by the plugins file.\\n      See [support issue](https://github.com/cypress-io/code-coverage/issues/179)\\n      for possible workarounds.\\n    \");\n  });\n} else {\n  registerHooks();\n}","map":null,"metadata":{},"sourceType":"script"}